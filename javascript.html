<script>
    new Vue({
        el: '#app',
        data: {
            viewMode: 'dashboard',
            layoutMode: 'grid',
            dashboardLanguage: 'de', // Default Dashboard Language
            editingVideo: {},
            tagInput: '',
            sourceInput: '',
            saving: false,
            translating: false,
            debounceTimer: null,
            loading: true,
            videos: [],
            error: null,
            filterStatus: 'All',
            prompter: {
                isScrolling: false,
                speed: 2,
                fontSize: 60,
                paragraphSpacing: 50, // Default pixels
                mirror: false,
                activeLanguage: 'de',
                isFullscreen: false,
                isInteracting: false, // Track manual scroll
                globalSettings: {}, // Store loaded global config
                updateKey: 0, // Force re-render key
                scrollIds: null
            }
        },
        computed: {
            filteredVideos() {
                let filtered = this.videos;

                // Filter by View/Status
                if (this.filterStatus !== 'All') {
                    filtered = filtered.filter(v => v.status === this.filterStatus);
                }

                const statusOrder = this.statuses;
                filtered.sort((a, b) => {
                    return statusOrder.indexOf(a.status) - statusOrder.indexOf(b.status);
                });

                return filtered;
            },
            statuses() {
                return ['idea', 'draft', 'discussion', 'recording_ready', 'recording', 'recorded', 'edit_ready', 'publish_ready', 'published'];
            },
            customTags() {
                return this.editingVideo.tags || '';
            },
            parsedSources() {
                let raw = this.editingVideo.source_link || '';
                let links = [];

                if (raw.trim().startsWith('[')) {
                    try {
                        links = JSON.parse(raw);
                    } catch (e) {
                        links = [];
                    }
                } else {
                    links = raw.split('\n').filter(Boolean).map(url => ({ url, text: url }));
                }

                return links.map(linkObj => {
                    const link = linkObj.url || linkObj;
                    let type = 'generic';
                    let thumb = linkObj.image || '';
                    let label = linkObj.title || linkObj.hostname || 'Link';
                    let color = 'gray';

                    const ytMatch = link.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/);
                    
                    if (ytMatch) {
                        type = 'youtube';
                        label = 'YouTube User'; 
                        color = 'red';
                        thumb = 'https://img.youtube.com/vi/' + ytMatch[1] + '/mqdefault.jpg';
                    } else if (link.indexOf('tiktok.com') !== -1) {
                        type = 'tiktok';
                        label = 'TikTok';
                        color = 'gray';
                    } else if (link.indexOf('instagram.com') !== -1) {
                        type = 'instagram';
                        label = 'Instagram';
                        color = 'pink';
                    }

                    return { url: link, type, thumb, label, color, description: linkObj.description };
                });
            },
            currentPrompterMarkdown() {
                const lang = this.prompter.activeLanguage;
                const title = (lang === 'de' ? this.editingVideo.title_de : this.editingVideo.title_en) || '';
                const text = (lang === 'de' ? this.editingVideo.text_de : this.editingVideo.text_en) || '';
                return `# ${title}\n\n${text}`;
            },
            hasPrompterContent() {
                const lang = this.prompter.activeLanguage;
                if (!this.editingVideo) return false;
                const text = (lang === 'de' ? this.editingVideo.text_de : this.editingVideo.text_en) || '';
                return text.trim().length > 0;
            }
        },
        mounted() {
            this.fetchVideos();
            this.loadPrompterSettings();

            setInterval(() => {
                // Poll ONLY in Teleprompter (for Director sync)
                // Dashboard update is manual (fetchVideos called on load/save/close)
                if (!this.saving && this.viewMode === 'teleprompter') {
                    this.fetchVideos(true);
                }
            }, 5000); 
        },
        methods: {
            fetchVideos(silent = false) {
                if (!silent) this.loading = true;
                google.script.run
                    .withSuccessHandler(this.onVideosLoaded)
                    .withFailureHandler(this.onFailure)
                    .getVideos();
            },
            onVideosLoaded(data) {
                if (this.viewMode === 'teleprompter') {
                    // Force Teleprompter Sync even if saving (background poll is essential for live updates)
                    const activeVideo = data.find(v => v.status === 'recording');
                    console.log("Teleprompter Sync Check. Active ID:", activeVideo ? activeVideo.id : 'None');
                    
                    if (activeVideo) {
                        // Scenario 1: Active Video Changed
                        if (activeVideo.id !== this.editingVideo.id) {
                            console.log("Auto-switching ID from", this.editingVideo.id, "to", activeVideo.id);
                            this.openTeleprompter(activeVideo);
                        } 
                        // Scenario 2: Same Video, Content Changed
                        else {
                            const fields = ['text_de', 'text_en', 'title_de', 'title_en'];
                            let updated = false;
                            
                            fields.forEach(field => {
                                if (this.editingVideo[field] !== activeVideo[field]) {
                                    console.log(`Field ${field} changed.`);
                                    this.$set(this.editingVideo, field, activeVideo[field]);
                                    updated = true;
                                }
                            });
                            
                            if (updated) {
                                console.log("Live Content Sync: FORCING RERENDER");
                                this.prompter.updateKey++; 
                            }
                        }
                    }
                }

                // Standard Dashboard Update (Respect saving lock to avoid flicker)
                if (this.saving) return;
                this.videos = data;
                this.loading = false;
            },

            onFailure(error) {
                this.error = "Error loading videos: " + error.message;
                this.loading = false;
            },
            prepareNewVideo() {
                if (this.viewMode === 'detail') this.saveVideo(null, true); // Background auto-save, skip UI update
                this.editingVideo = { status: 'draft', title_de: '', text_de: '', source_link: '[]', tags: '' };
                this.tagInput = '';
                this.sourceInput = '';
                this.viewMode = 'detail';
                this.triggerAllAutoGrow();
            },
            editOldestDraft() {
                if (this.viewMode === 'detail') this.saveVideo(null, true); // Background auto-save
                // Find all drafts
                const drafts = this.videos.filter(v => v.status === 'draft');
                if (drafts.length === 0) {
                    alert("No drafts found.");
                    return;
                }
                // "lowest on the sheet list" corresponds to the last matching element in the raw array
                const oldestDraft = drafts[drafts.length - 1]; 
                this.openDetailView(oldestDraft);
            },
            openDetailView(video) {
                this.editingVideo = JSON.parse(JSON.stringify(video));
                this._originalVideoState = JSON.stringify(this.editingVideo); // Track for changes
                this.tagInput = '';
                this.sourceInput = '';
                this.viewMode = 'detail';
                this.triggerAllAutoGrow();
            },
            openNextVideo() {
                // AUTO-SAVE before moving
                this.saveVideo(() => {
                    const list = this.filteredVideos;
                    const currentIndex = list.findIndex(v => v.id === this.editingVideo.id);
                    
                    if (currentIndex !== -1 && currentIndex < list.length - 1) {
                        const nextWithId = list[currentIndex + 1];
                        this.openDetailView(nextWithId);
                    } else {
                        alert("This is the last video in the current list.");
                    }
                });
            },
            closeDetailView() {
                // BLOCKING SAVE: Ensuring notes are saved before returning to dashboard
                // This prevents race conditions where the dashboard shows old data.
                this.saveVideo(() => {
                    this.viewMode = 'dashboard';
                }, true); // skipUpdate as we are leaving
            },
            saveVideo(onSuccess, skipUpdate = false) {
                // DEFENSIVE CLONING: Capture data immediately to prevent race conditions during navigation
                const dataToSave = JSON.parse(JSON.stringify(this.editingVideo || {}));
                
                // Guard: Don't save if object is empty or missing critical status (e.g. if navigation already cleared it)
                if (!dataToSave.status) return;

                this.saving = true;
                google.script.run
                    .withSuccessHandler((savedVideo) => {
                        this.saving = false;
                        if (savedVideo && typeof savedVideo === 'object') {
                            // 1. Update the item in the master list for instant dashboard updates
                            const idx = this.videos.findIndex(v => v.id === savedVideo.id);
                            if (idx !== -1) {
                                this.$set(this.videos, idx, JSON.parse(JSON.stringify(savedVideo)));
                            } else if (savedVideo.id) {
                                this.videos.unshift(JSON.parse(JSON.stringify(savedVideo)));
                            }

                            // 2. Update local editing state if we are still in detail view
                            const currentId = this.editingVideo ? this.editingVideo.id : null;
                            if (this.viewMode === 'detail' && (currentId === savedVideo.id || !currentId)) {
                                this.editingVideo = JSON.parse(JSON.stringify(savedVideo));
                                this.triggerAllAutoGrow(); 
                            }
                        }
                        this.fetchVideos(true);
                        if (onSuccess && typeof onSuccess === 'function') onSuccess(savedVideo);
                    })
                    .withFailureHandler((err) => {
                        this.saving = false;
                        alert("Save Failed: " + err.message);
                    })
                    .saveVideo(dataToSave);
            },
            autoGrow(e) {
                const el = e.target || e;
                if (!el) return;
                el.style.height = "auto";
                el.style.height = (el.scrollHeight) + "px";
            },
            triggerAllAutoGrow() {
                this.$nextTick(() => {
                    const textareas = document.querySelectorAll('textarea');
                    textareas.forEach(el => {
                        el.style.height = "auto";
                        el.style.height = (el.scrollHeight) + "px";
                    });
                });
            },
            deleteVideo(video) {
                // If video is passed (Dashboard delete), use it. Otherwise use editingVideo (Detail delete).
                const targetId = video ? video.id : this.editingVideo.id;
                
                if(!confirm("Are you sure you want to delete this video? This cannot be undone.")) return;
                
                // If deleting the currently open video, we show saving state
                if (!video) this.saving = true;

                google.script.run
                    .withSuccessHandler(() => {
                        this.saving = false;
                        if (!video) this.closeDetailView(); // Close only if inside detail view
                        this.fetchVideos(true);
                    })
                    .withFailureHandler((err) => {
                        this.saving = false;
                        alert("Delete Failed: " + err);
                    })
                    .deleteVideo(targetId);
            },
            getStatusColor(status) {
                const colors = {
                    'idea': 'bg-blue-100 text-blue-800',
                    'draft': 'bg-gray-200 text-gray-800',
                    'discussion': 'bg-orange-100 text-orange-800',
                    'recording_ready': 'bg-yellow-100 text-yellow-800',
                    'recording': 'bg-red-600 text-white',
                    'recorded': 'bg-teal-100 text-teal-800',
                    'edit_ready': 'bg-purple-100 text-purple-800',
                    'publish_ready': 'bg-green-100 text-green-800',
                    'published': 'bg-green-500 text-white'
                };
                return colors[status] || 'bg-gray-100';
            },
            translateField(text, targetField) {
                if (!text) {
                    this.$set(this.editingVideo, targetField, "");
                    return;
                }
                this.translating = true;
                google.script.run
                    .withSuccessHandler((translatedText) => {
                        this.$set(this.editingVideo, targetField, translatedText);
                        this.translating = false;
                        this.triggerAllAutoGrow();
                    })
                    .withFailureHandler(() => {
                        this.translating = false;
                    })
                    .translateText(text, 'de', 'en');
            },
            debouncedTranslate(field, val) {
                if (this.debounceTimer) clearTimeout(this.debounceTimer);
                this.debounceTimer = setTimeout(() => {
                    const target = field === 'title_de' ? 'title_en' : 'text_en';
                    this.translateField(val, target);
                }, 1000);
            },
            addTag() {
                if (!this.tagInput) return;
                const newTag = this.tagInput.trim().replace(/^#/, '');
                if (!newTag) return;
                
                let currentTags = this.customTags ? this.customTags.split(',').map(t => t.trim()).filter(Boolean) : [];
                if (!currentTags.includes(newTag)) {
                    currentTags.push(newTag);
                    this.$set(this.editingVideo, 'tags', currentTags.join(', '));
                }
                this.tagInput = '';
            },
            removeTag(index) {
                let currentTags = this.customTags ? this.customTags.split(',').map(t => t.trim()).filter(Boolean) : [];
                currentTags.splice(index, 1);
                this.$set(this.editingVideo, 'tags', currentTags.join(', '));
            },
            // UPGRADED ASYNC SOURCE ADD
            addSource() {
                if (!this.sourceInput) return;
                const newLink = this.sourceInput.trim();
                if (!newLink) return;

                // Disable input while fetching
                const originalInput = this.sourceInput;
                this.sourceInput = 'Fetching Preview...';

                google.script.run
                 .withSuccessHandler((meta) => {
                     let current = [];
                     const raw = this.editingVideo.source_link || '';
                     if (raw.startsWith('[')) {
                         try { current = JSON.parse(raw); } catch(e) {}
                     } else {
                         current = raw.split('\n').filter(Boolean).map(u => ({ url: u })); 
                     }

                     // Push new metadata object
                     if (meta.success) {
                        current.push(meta); 
                     } else {
                         // Fallback if fetch failed
                        current.push({ url: newLink, title: newLink });
                     }

                     // Save back as JSON string
                     this.$set(this.editingVideo, 'source_link', JSON.stringify(current));
                     this.sourceInput = ''; // Clear
                 })
                 .withFailureHandler((err) => {
                     alert("Could not fetch link: " + err);
                     this.sourceInput = originalInput;
                 })
                 .fetchLinkMetadata(newLink);
            },
            removeSource(index) {
                let current = [];
                const raw = this.editingVideo.source_link || '';
                if (raw.startsWith('[')) {
                    try { current = JSON.parse(raw); } catch(e) {}
                 } else {
                    current = raw.split('\n').filter(Boolean).map(u => ({ url: u })); 
                 }
                
                current.splice(index, 1);
                this.$set(this.editingVideo, 'source_link', JSON.stringify(current));
            },
            openLink(url) {
                window.open(url, '_blank');
            },
            // DIRECTOR: Set active recording
            setRecordingStatus(video) {
                // LOCK Polling to prevent race condition
                this.saving = true; 

                // 1. Optimistic UI Update
                const targetId = video.id;
                this.videos.forEach(v => {
                    if (v.id === targetId) {
                        v.status = 'recording';
                    } else if (v.status === 'recording') {
                        v.status = 'recording_ready';
                    }
                });

                // 2. Sync Detail View if open and matching
                if (this.editingVideo && this.editingVideo.id === targetId) {
                    this.editingVideo.status = 'recording';
                    // If other video was open? Unlikely edge case, not handled here.
                }

                // 3. Server Call
                google.script.run
                    .withSuccessHandler(() => {
                        console.log("Recording status synced.");
                        this.saving = false; // Release lock
                        this.fetchVideos(true); // Fetch immediately to confirm server state
                    })
                    .withFailureHandler((err) => {
                        alert("Failed to set recording status: " + err);
                        this.saving = false; // Release lock
                        this.fetchVideos(); // Revert on error
                    })
                    .setAsActiveRecording(targetId);
            },
            // TELEPROMPTER LOGIC
            openTeleprompter(video) {
                this.editingVideo = JSON.parse(JSON.stringify(video));
                this.viewMode = 'teleprompter';
                
                // Initialize Prompter State
                this.prompter.isScrolling = false;
                this.prompter.activeLanguage = 'de'; // Default
                this.prompter.isFullscreen = false;
                this.prompter.isInteracting = false; // Track manual scroll

                // Load Settings for Default Language
                this.loadPrompterSettings();

                // Auto-play by default
                this.$nextTick(() => {
                    this.startScrolling();
                });
            },
            handleInteractionStart() {
                this.prompter.isInteracting = true;
            },
            handleInteractionEnd() {
                this.prompter.isInteracting = false;
            },
            handleWheel() {
                // Wheel doesn't have a clear "end", so we debounce it
                this.prompter.isInteracting = true;
                if (this.wheelTimer) clearTimeout(this.wheelTimer);
                this.wheelTimer = setTimeout(() => {
                    this.prompter.isInteracting = false;
                }, 150);
            },
            closeTeleprompter() {
                this.stopScrolling();
                if (document.fullscreenElement) document.exitFullscreen().catch(e => {});
                this.viewMode = 'dashboard';
                this.editingVideo = {};
            },
            closeTeleprompterToDetail() {
                this.stopScrolling();
                if (document.fullscreenElement) document.exitFullscreen().catch(e => {});
                this.viewMode = 'detail';
            },
            toggleTeleprompter() {
                if (this.viewMode === 'teleprompter') {
                    this.closeTeleprompterToDetail();
                } else if (this.viewMode === 'detail') {
                    if (this.hasPrompterContent) {
                        // AUTO-SAVE before entering Teleprompter
                        this.saveVideo(() => {
                            this.openTeleprompter(this.editingVideo);
                        });
                    }
                }
            },
            loadPrompterSettings() {
                // FETCH GLOBAL SETTINGS
                google.script.run
                    .withSuccessHandler(settings => {
                        this.prompter.globalSettings = settings || {};
                        
                        // Restore Teleprompter Language
                        if (this.prompter.globalSettings.activeLanguage) {
                            this.prompter.activeLanguage = this.prompter.globalSettings.activeLanguage;
                        }

                        // Restore Dashboard Language
                        if (this.prompter.globalSettings.dashboardLanguage) {
                            this.dashboardLanguage = this.prompter.globalSettings.dashboardLanguage;
                        }

                        // Apply Settings for current language
                        this.applyRuntimeSettings();
                    })
                    .withFailureHandler(err => console.error("Failed to load global settings", err))
                    .getGlobalSettings();
            },
            switchDashboardLanguage(lang) {
                this.dashboardLanguage = lang;
                
                // Persist
                if (!this.prompter.globalSettings) this.prompter.globalSettings = {};
                this.prompter.globalSettings.dashboardLanguage = lang;
                
                this.savePrompterSettings(); // Uses the global save mechanism
            },
            applyRuntimeSettings() {
                const lang = this.prompter.activeLanguage;
                const langSettings = (this.prompter.globalSettings && this.prompter.globalSettings[lang]) || {};

                // Apply to Runtime State (Fallbacks)
                this.prompter.fontSize = langSettings.fontSize || 60;
                this.prompter.paragraphSpacing = langSettings.paragraphSpacing || 50;
                this.prompter.speed = (langSettings.speed !== undefined) ? langSettings.speed : 25;
            },
            switchLanguage(lang) {
                if (this.prompter.activeLanguage === lang) return;
                
                // 1. Sync current state to global object
                this.syncToGlobalObject();
                
                // 2. Switch
                this.prompter.activeLanguage = lang;
                
                // 3. Mark new language in global object
                if (!this.prompter.globalSettings) this.prompter.globalSettings = {};
                this.prompter.globalSettings.activeLanguage = lang;

                // 4. Apply new language settings
                this.applyRuntimeSettings();

                // 5. Trigger Save
                this.debouncedSaveSettings();
            },
            updateSettingsObject() {
                this.syncToGlobalObject();
                this.debouncedSaveSettings();
            },
            syncToGlobalObject() {
                if (!this.prompter.globalSettings) this.prompter.globalSettings = {};
                
                const lang = this.prompter.activeLanguage;
                // Ensure language key exists
                if (!this.prompter.globalSettings[lang]) this.prompter.globalSettings[lang] = {};

                const target = this.prompter.globalSettings[lang];
                target.fontSize = this.prompter.fontSize;
                target.paragraphSpacing = this.prompter.paragraphSpacing;
                target.speed = this.prompter.speed;

                // Also save active language preference
                this.prompter.globalSettings.activeLanguage = this.prompter.activeLanguage;
            },
            debouncedSaveSettings() {
               if (this.debounceTimer) clearTimeout(this.debounceTimer);
               this.debounceTimer = setTimeout(() => {
                   this.savePrompterSettings();
               }, 1000); 
            },
            savePrompterSettings() {
                // Call Global Save
                google.script.run
                    .withFailureHandler(err => console.error("Global Settings Save Failed", err))
                    .saveGlobalSettings(this.prompter.globalSettings);
            },
            toggleFullScreen() {
                const elem = document.documentElement;
                if (!document.fullscreenElement) {
                    elem.requestFullscreen().then(() => {
                        this.prompter.isFullscreen = true;
                    }).catch(err => {
                        alert(`Error attempting to enable full-screen mode: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen().then(() => {
                        this.prompter.isFullscreen = false;
                    });
                }
            },
            toggleScrolling() {
                if (this.prompter.isScrolling) {
                    this.stopScrolling();
                } else {
                    this.startScrolling();
                }
            },
            startScrolling() {
                if (this.prompter.isScrolling) return;
                this.prompter.isScrolling = true;
                
                const container = document.getElementById('prompter-content');
                if (!container) return; // Safety

                // SUB-PIXEL SCROLLING FIX:
                // Browsers often truncate scrollTop assignments. We must track the precise float value.
                let preciseScrollTop = container.scrollTop;

                const scrollStep = () => {
                    if (!this.prompter.isScrolling) return;
                    
                    // INTERACTION CHECK:
                    // If user is holding mouse or touching, strictly sync tracker and SKIP increment.
                    // This prevents "fighting" the user's manual scroll.
                    if (this.prompter.isInteracting) {
                        preciseScrollTop = container.scrollTop;
                        this.prompter.scrollIds = requestAnimationFrame(scrollStep);
                        return; 
                    }

                    // MANUAL SCROLL RESUME (Failsafe):
                    // If we are NOT determining interaction but the position jumped significantly
                    // (e.g. momentum scroll or wheel without event), sync to it.
                    if (Math.abs(container.scrollTop - preciseScrollTop) > 5.0) {
                        preciseScrollTop = container.scrollTop;
                    }
                    
                    
                    // Apply Increment
                    // User Request: Map 0-100 slider to previous 0-30 range.
                    // Previous Max @ 30 = 30 * 0.1 = 3.0px/frame
                    // New Max @ 100 = 100 * 0.03 = 3.0px/frame
                    const pixels = this.prompter.speed * 0.03;
                    preciseScrollTop += pixels;
                    container.scrollTop = preciseScrollTop;

                    // Loop
                    this.prompter.scrollIds = requestAnimationFrame(scrollStep);
                };
                this.prompter.scrollIds = requestAnimationFrame(scrollStep);
            },
            stopScrolling() {
                this.prompter.isScrolling = false;
                if (this.prompter.scrollIds) cancelAnimationFrame(this.prompter.scrollIds);
            },
            completeCurrentAndNext(targetStatus) {
                // Find all recording_ready videos
                const recordingReady = this.videos.filter(v => v.status === 'recording_ready');
                
                // "Lowest on the sheet list" is the last element in the array (newest first array)
                // Wait, getVideos() returns .reverse() (newest first). 
                // So the "oldest" (lowest on sheet) is the LAST index.
                const nextVideo = recordingReady.length > 0 ? recordingReady[recordingReady.length - 1] : null;

                this.stopScrolling();
                this.saving = true;

                if (nextVideo) {
                    google.script.run
                        .withSuccessHandler(() => {
                            this.saving = false;
                            this.fetchVideos(true); 
                        })
                        .withFailureHandler((err) => {
                            alert("Error switching video: " + err);
                            this.saving = false;
                        })
                        .finishAndNextRecording(this.editingVideo.id, nextVideo.id, targetStatus);
                } else {
                    google.script.run
                        .withSuccessHandler(() => {
                            this.saving = false;
                            this.closeTeleprompter();
                            this.fetchVideos(true);
                        })
                        .withFailureHandler((err) => {
                            alert("Error updating status: " + err);
                            this.saving = false;
                        })
                        .updateVideoStatus(this.editingVideo.id, targetStatus);
                }
            },
            // UTILS
            getVideoTitle(video) {
                return this.dashboardLanguage === 'de' ? video.title_de : video.title_en;
            },
            getVideoTeaser(video) {
                const text = this.dashboardLanguage === 'de' ? video.text_de : video.text_en;
                if (!text) return 'No Text';
                return text.length > 60 ? text.substring(0, 60) + '...' : text;
            },
            renderMarkdown(text) {
                if (!text) return '';
                
                // FORCE PARAGRAPHS: Turn single Sheet newlines into Markdown double-newlines
                // This ensures every line in the Sheet becomes a distinct paragraph
                // which can then be spaced by the slider.
                const formatted = text.replace(/\n/g, '\n\n');
                
                // Configure marked to break on single newlines if desired, or standard markdown
                // marked.setOptions({ breaks: true }); 
                return marked.parse(formatted);
            }
        }
    });
</script>