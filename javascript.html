<script>
    new Vue({
        el: '#app',
        data: {
            currentRole: 'All',
            viewMode: 'dashboard',
            layoutMode: 'grid',
            dashboardLanguage: 'de', // Default Dashboard Language
            editingVideo: {},
            tagInput: '',
            sourceInput: '',
            saving: false,
            translating: false,
            debounceTimer: null,
            loading: true,
            videos: [],
            error: null,
            filterStatus: 'All',
            prompter: {
                isScrolling: false,
                speed: 2,
                fontSize: 60,
                paragraphSpacing: 50, // Default pixels
                mirror: false,
                activeLanguage: 'de',
                isFullscreen: false,
                isInteracting: false, // Track manual scroll
                globalSettings: {}, // Store loaded global config
                updateKey: 0, // Force re-render key
                scrollIds: null
            }
        },
        computed: {
            filteredVideos() {
                let filtered = this.videos;

                // 1. Filter by Role
                if (this.currentRole !== 'All') {
                    let roleStatuses = [];
                    if (this.currentRole === 'Author') roleStatuses = ['draft'];
                    else if (this.currentRole === 'Director') roleStatuses = ['recording_ready', 'recording'];
                    else if (this.currentRole === 'Speaker') roleStatuses = ['recording'];
                    else if (this.currentRole === 'Editor') roleStatuses = ['edit_ready'];
                    else if (this.currentRole === 'Manager') roleStatuses = ['publish_ready', 'published'];
                    
                    filtered = filtered.filter(v => roleStatuses.includes(v.status));
                }

                // 2. Filter by View/Status
                if (this.filterStatus !== 'All') {
                    filtered = filtered.filter(v => v.status === this.filterStatus);
                }

                const statusOrder = this.statuses;
                filtered.sort((a, b) => {
                    return statusOrder.indexOf(a.status) - statusOrder.indexOf(b.status);
                });

                return filtered;
            },
            statuses() {
                return ['draft', 'recording_ready', 'recording', 'edit_ready', 'publish_ready', 'published'];
            },
            customTags() {
                return this.editingVideo.tags || '';
            },
            // PARSES BOTH LEGACY STRINGS AND NEW JSON OBJECTS
            parsedSources() {
                // Ensure we handle the source_link whether it's a newline string OR a JSON string
                let raw = this.editingVideo.source_link || '';
                let links = [];

                // Detect if JSON
                if (raw.trim().startsWith('[')) {
                    try {
                        links = JSON.parse(raw);
                    } catch (e) {
                        links = []; // Fallback
                    }
                } else {
                    // Legacy: split by newline, convert to simple objects
                    links = raw.split('\n').filter(Boolean).map(url => ({ url, text: url })); // text fallback
                }

                return links.map(linkObj => {
                    const link = linkObj.url || linkObj;
                    let type = 'generic';
                    let thumb = linkObj.image || ''; // Use metadata image if available
                    let label = linkObj.title || linkObj.hostname || 'Link';
                    let color = 'gray';

                    // YouTube (Auto-detect overrides metadata if its a direct YT link, usually better thumb)
                    const ytMatch = link.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/);
                    
                    if (ytMatch) {
                        type = 'youtube';
                        label = 'YouTube User'; 
                        color = 'red';
                        thumb = 'https://img.youtube.com/vi/' + ytMatch[1] + '/mqdefault.jpg';
                    } else if (link.indexOf('tiktok.com') !== -1) {
                        type = 'tiktok';
                        label = 'TikTok';
                        color = 'gray';
                    } else if (link.indexOf('instagram.com') !== -1) {
                        type = 'instagram';
                        label = 'Instagram';
                        color = 'pink';
                    } else if (!thumb) {
                         // Logic for generic without metadata image?
                         // We rely on the object having it.
                    }

                    return { url: link, type, thumb, label, color, description: linkObj.description };
                });
            },
            currentPrompterMarkdown() {
                const lang = this.prompter.activeLanguage;
                // Get content based on language
                const title = (lang === 'de' ? this.editingVideo.title_de : this.editingVideo.title_en) || '';
                const text = (lang === 'de' ? this.editingVideo.text_de : this.editingVideo.text_en) || '';
                
                // Combine: Title (H1) + Spacing + Text
                return `# ${title}\n\n${text}`;
            }
        },
        mounted() {
            this.fetchVideos();

            setInterval(() => {
                // Poll if in Dashboard OR Teleprompter (for auto-switch)
                // But NOT if we are actively saving (this.saving)
                if (!this.saving && (this.viewMode === 'dashboard' || this.viewMode === 'teleprompter')) {
                    this.fetchVideos(true);
                }
            }, 4000); // Increased to 4s to avoid "Too many scripts" quota error
        },
        methods: {
            fetchVideos(silent = false) {
                if (!silent) this.loading = true;
                google.script.run
                    .withSuccessHandler(this.onVideosLoaded)
                    .withFailureHandler(this.onFailure)
                    .getVideos();
            },
            onVideosLoaded(data) {
                console.log("Videos loaded:", data.length);
                if (this.viewMode === 'teleprompter') {
                    // Force Teleprompter Sync even if saving (background poll is essential for live updates)
                    const activeVideo = data.find(v => v.status === 'recording');
                    console.log("Teleprompter Sync Check. Active ID:", activeVideo ? activeVideo.id : 'None');
                    
                    if (activeVideo) {
                        // Scenario 1: Active Video Changed
                        if (activeVideo.id !== this.editingVideo.id) {
                            console.log("Auto-switching ID from", this.editingVideo.id, "to", activeVideo.id);
                            this.openTeleprompter(activeVideo);
                        } 
                        // Scenario 2: Same Video, Content Changed
                        else {
                            const fields = ['text_de', 'text_en', 'title_de', 'title_en'];
                            let updated = false;
                            
                            fields.forEach(field => {
                                if (this.editingVideo[field] !== activeVideo[field]) {
                                    console.log(`Field ${field} changed.`);
                                    this.$set(this.editingVideo, field, activeVideo[field]);
                                    updated = true;
                                }
                            });
                            
                            if (updated) {
                                console.log("Live Content Sync: FORCING RERENDER");
                                this.prompter.updateKey++; 
                            }
                        }
                    }
                }

                // Standard Dashboard Update (Respect saving lock to avoid flicker)
                if (this.saving) return;
                this.videos = data;
                this.loading = false;
            },

            onFailure(error) {
                this.error = "Error loading videos: " + error.message;
                this.loading = false;
            },
            openNewVideoModal() {
                this.editingVideo = { status: 'draft' };
                this.viewMode = 'edit';
            },
            openEditModal(video) {
                this.editingVideo = JSON.parse(JSON.stringify(video));
                this.viewMode = 'edit';
            },
            openDetailView(video) {
                // SMART CLICK: If Speaker + Recording -> Open Teleprompter directly
                if (this.currentRole === 'Speaker' && video.status === 'recording') {
                    this.openTeleprompter(video);
                    return;
                }

                this.editingVideo = JSON.parse(JSON.stringify(video));
                this.tagInput = '';
                this.sourceInput = '';
                this.viewMode = 'detail';
            },
            openNextVideo() {
                const list = this.filteredVideos;
                // Find current video index
                const currentIndex = list.findIndex(v => v.id === this.editingVideo.id);
                
                if (currentIndex !== -1 && currentIndex < list.length - 1) {
                    // Open Next
                    const nextWithId = list[currentIndex + 1];
                    // We must refetch/find full object from Main Videos list if filtered list is subset? 
                    // Actually filteredVideos contains full objects.
                    this.openDetailView(nextWithId);
                } else {
                    alert("This is the last video in the current list.");
                }
            },
            closeDetailView() {
                this.viewMode = 'dashboard';
                this.editingVideo = {};
            },
            closeModal() {
                this.viewMode = 'dashboard';
                this.editingVideo = {};
            },
            saveVideo() {
                this.saving = true;
                const wasEditing = this.viewMode === 'edit';
                google.script.run
                    .withSuccessHandler(() => {
                        this.saving = false;
                        if (wasEditing) {
                            this.closeModal();
                        }
                        this.fetchVideos(true);
                    })
                    .withFailureHandler((err) => {
                        this.saving = false;
                        alert("Save Failed: " + err.message);
                    })
                    .saveVideo(this.editingVideo);
            },
            deleteVideo(video) {
                // If video is passed (Dashboard delete), use it. Otherwise use editingVideo (Detail delete).
                const targetId = video ? video.id : this.editingVideo.id;
                
                if(!confirm("Are you sure you want to delete this video? This cannot be undone.")) return;
                
                // If deleting the currently open video, we show saving state
                if (!video) this.saving = true;

                google.script.run
                    .withSuccessHandler(() => {
                        this.saving = false;
                        if (!video) this.closeDetailView(); // Close only if inside detail view
                        this.fetchVideos(true);
                    })
                    .withFailureHandler((err) => {
                        this.saving = false;
                        alert("Delete Failed: " + err);
                    })
                    .deleteVideo(targetId);
            },
            getStatusColor(status) {
                const colors = {
                    'draft': 'bg-gray-200 text-gray-800',
                    'recording_ready': 'bg-yellow-100 text-yellow-800',
                    'recording': 'bg-red-100 text-red-800',
                    'edit_ready': 'bg-purple-100 text-purple-800',
                    'publish_ready': 'bg-green-100 text-green-800',
                    'published': 'bg-green-500 text-white'
                };
                return colors[status] || 'bg-gray-100';
            },
            translateField(text, targetField) {
                if (!text) {
                    this.$set(this.editingVideo, targetField, "");
                    return;
                }
                this.translating = true;
                google.script.run
                    .withSuccessHandler((translatedText) => {
                        this.$set(this.editingVideo, targetField, translatedText);
                        this.translating = false;
                    })
                    .withFailureHandler(() => {
                        this.translating = false;
                    })
                    .translateText(text, 'de', 'en');
            },
            debouncedTranslate(field, val) {
                if (this.debounceTimer) clearTimeout(this.debounceTimer);
                this.debounceTimer = setTimeout(() => {
                    const target = field === 'title_de' ? 'title_en' : 'text_en';
                    this.translateField(val, target);
                }, 1000);
            },
            addTag() {
                if (!this.tagInput) return;
                const newTag = this.tagInput.trim().replace(/^#/, '');
                if (!newTag) return;
                
                let currentTags = this.customTags ? this.customTags.split(',').map(t => t.trim()).filter(Boolean) : [];
                if (!currentTags.includes(newTag)) {
                    currentTags.push(newTag);
                    this.$set(this.editingVideo, 'tags', currentTags.join(', '));
                }
                this.tagInput = '';
            },
            removeTag(index) {
                let currentTags = this.customTags ? this.customTags.split(',').map(t => t.trim()).filter(Boolean) : [];
                currentTags.splice(index, 1);
                this.$set(this.editingVideo, 'tags', currentTags.join(', '));
            },
            // UPGRADED ASYNC SOURCE ADD
            addSource() {
                if (!this.sourceInput) return;
                const newLink = this.sourceInput.trim();
                if (!newLink) return;

                // Disable input while fetching
                const originalInput = this.sourceInput;
                this.sourceInput = 'Fetching Preview...';

                google.script.run
                 .withSuccessHandler((meta) => {
                     let current = [];
                     const raw = this.editingVideo.source_link || '';
                     if (raw.startsWith('[')) {
                         try { current = JSON.parse(raw); } catch(e) {}
                     } else {
                         current = raw.split('\n').filter(Boolean).map(u => ({ url: u })); 
                     }

                     // Push new metadata object
                     if (meta.success) {
                        current.push(meta); 
                     } else {
                         // Fallback if fetch failed
                        current.push({ url: newLink, title: newLink });
                     }

                     // Save back as JSON string
                     this.$set(this.editingVideo, 'source_link', JSON.stringify(current));
                     this.sourceInput = ''; // Clear
                 })
                 .withFailureHandler((err) => {
                     alert("Could not fetch link: " + err);
                     this.sourceInput = originalInput;
                 })
                 .fetchLinkMetadata(newLink);
            },
            removeSource(index) {
                let current = [];
                const raw = this.editingVideo.source_link || '';
                if (raw.startsWith('[')) {
                    try { current = JSON.parse(raw); } catch(e) {}
                 } else {
                    current = raw.split('\n').filter(Boolean).map(u => ({ url: u })); 
                 }
                
                current.splice(index, 1);
                this.$set(this.editingVideo, 'source_link', JSON.stringify(current));
            },
            openLink(url) {
                window.open(url, '_blank');
            },
            // DIRECTOR: Set active recording
            setRecordingStatus(video) {
                // LOCK Polling to prevent race condition
                this.saving = true; 

                // 1. Optimistic UI Update
                const targetId = video.id;
                this.videos.forEach(v => {
                    if (v.id === targetId) {
                        v.status = 'recording';
                    } else if (v.status === 'recording') {
                        v.status = 'recording_ready';
                    }
                });

                // 2. Sync Detail View if open and matching
                if (this.editingVideo && this.editingVideo.id === targetId) {
                    this.editingVideo.status = 'recording';
                    // If other video was open? Unlikely edge case, not handled here.
                }

                // 3. Server Call
                google.script.run
                    .withSuccessHandler(() => {
                        console.log("Recording status synced.");
                        this.saving = false; // Release lock
                        this.fetchVideos(true); // Fetch immediately to confirm server state
                    })
                    .withFailureHandler((err) => {
                        alert("Failed to set recording status: " + err);
                        this.saving = false; // Release lock
                        this.fetchVideos(); // Revert on error
                    })
                    .setAsActiveRecording(targetId);
            },
            // TELEPROMPTER LOGIC
            openTeleprompter(video) {
                this.editingVideo = JSON.parse(JSON.stringify(video));
                this.viewMode = 'teleprompter';
                
                // Initialize Prompter State
                this.prompter.isScrolling = false;
                this.prompter.activeLanguage = 'de'; // Default
                this.prompter.isFullscreen = false;
                this.prompter.isInteracting = false; // Track manual scroll

                // Load Settings for Default Language
                this.loadPrompterSettings();
            },
            handleInteractionStart() {
                this.prompter.isInteracting = true;
            },
            handleInteractionEnd() {
                this.prompter.isInteracting = false;
            },
            handleWheel() {
                // Wheel doesn't have a clear "end", so we debounce it
                this.prompter.isInteracting = true;
                if (this.wheelTimer) clearTimeout(this.wheelTimer);
                this.wheelTimer = setTimeout(() => {
                    this.prompter.isInteracting = false;
                }, 150);
            },
            closeTeleprompter() {
                this.stopScrolling();
                if (document.fullscreenElement) document.exitFullscreen().catch(e => {});
                this.viewMode = 'dashboard';
                this.editingVideo = {};
            },
            loadPrompterSettings() {
                // FETCH GLOBAL SETTINGS
                google.script.run
                    .withSuccessHandler(settings => {
                        this.prompter.globalSettings = settings || {};
                        
                        // Restore Teleprompter Language
                        if (this.prompter.globalSettings.activeLanguage) {
                            this.prompter.activeLanguage = this.prompter.globalSettings.activeLanguage;
                        }

                        // Restore Dashboard Language
                        if (this.prompter.globalSettings.dashboardLanguage) {
                            this.dashboardLanguage = this.prompter.globalSettings.dashboardLanguage;
                        }

                        // Apply Settings for current language
                        this.applyRuntimeSettings();
                    })
                    .withFailureHandler(err => console.error("Failed to load global settings", err))
                    .getGlobalSettings();
            },
            switchDashboardLanguage(lang) {
                this.dashboardLanguage = lang;
                
                // Persist
                if (!this.prompter.globalSettings) this.prompter.globalSettings = {};
                this.prompter.globalSettings.dashboardLanguage = lang;
                
                this.savePrompterSettings(); // Uses the global save mechanism
            },
            applyRuntimeSettings() {
                const lang = this.prompter.activeLanguage;
                const langSettings = (this.prompter.globalSettings && this.prompter.globalSettings[lang]) || {};

                // Apply to Runtime State (Fallbacks)
                this.prompter.fontSize = langSettings.fontSize || 60;
                this.prompter.paragraphSpacing = langSettings.paragraphSpacing || 50;
                this.prompter.speed = (langSettings.speed !== undefined) ? langSettings.speed : 25;
            },
            switchLanguage(lang) {
                if (this.prompter.activeLanguage === lang) return;
                
                // 1. Sync current state to global object
                this.syncToGlobalObject();
                
                // 2. Switch
                this.prompter.activeLanguage = lang;
                
                // 3. Mark new language in global object
                if (!this.prompter.globalSettings) this.prompter.globalSettings = {};
                this.prompter.globalSettings.activeLanguage = lang;

                // 4. Apply new language settings
                this.applyRuntimeSettings();

                // 5. Trigger Save
                this.debouncedSaveSettings();
            },
            updateSettingsObject() {
                this.syncToGlobalObject();
                this.debouncedSaveSettings();
            },
            syncToGlobalObject() {
                if (!this.prompter.globalSettings) this.prompter.globalSettings = {};
                
                const lang = this.prompter.activeLanguage;
                // Ensure language key exists
                if (!this.prompter.globalSettings[lang]) this.prompter.globalSettings[lang] = {};

                const target = this.prompter.globalSettings[lang];
                target.fontSize = this.prompter.fontSize;
                target.paragraphSpacing = this.prompter.paragraphSpacing;
                target.speed = this.prompter.speed;

                // Also save active language preference
                this.prompter.globalSettings.activeLanguage = this.prompter.activeLanguage;
            },
            debouncedSaveSettings() {
               if (this.debounceTimer) clearTimeout(this.debounceTimer);
               this.debounceTimer = setTimeout(() => {
                   this.savePrompterSettings();
               }, 1000); 
            },
            savePrompterSettings() {
                // Call Global Save
                google.script.run
                    .withFailureHandler(err => console.error("Global Settings Save Failed", err))
                    .saveGlobalSettings(this.prompter.globalSettings);
            },
            toggleFullScreen() {
                const elem = document.documentElement;
                if (!document.fullscreenElement) {
                    elem.requestFullscreen().then(() => {
                        this.prompter.isFullscreen = true;
                    }).catch(err => {
                        alert(`Error attempting to enable full-screen mode: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen().then(() => {
                        this.prompter.isFullscreen = false;
                    });
                }
            },
            toggleScrolling() {
                if (this.prompter.isScrolling) {
                    this.stopScrolling();
                } else {
                    this.startScrolling();
                }
            },
            startScrolling() {
                if (this.prompter.isScrolling) return;
                this.prompter.isScrolling = true;
                
                const container = document.getElementById('prompter-content');
                if (!container) return; // Safety

                // SUB-PIXEL SCROLLING FIX:
                // Browsers often truncate scrollTop assignments. We must track the precise float value.
                let preciseScrollTop = container.scrollTop;

                const scrollStep = () => {
                    if (!this.prompter.isScrolling) return;
                    
                    // INTERACTION CHECK:
                    // If user is holding mouse or touching, strictly sync tracker and SKIP increment.
                    // This prevents "fighting" the user's manual scroll.
                    if (this.prompter.isInteracting) {
                        preciseScrollTop = container.scrollTop;
                        this.prompter.scrollIds = requestAnimationFrame(scrollStep);
                        return; 
                    }

                    // MANUAL SCROLL RESUME (Failsafe):
                    // If we are NOT determining interaction but the position jumped significantly
                    // (e.g. momentum scroll or wheel without event), sync to it.
                    if (Math.abs(container.scrollTop - preciseScrollTop) > 5.0) {
                        preciseScrollTop = container.scrollTop;
                    }
                    
                    
                    // Apply Increment
                    // User Request: Map 0-100 slider to previous 0-30 range.
                    // Previous Max @ 30 = 30 * 0.1 = 3.0px/frame
                    // New Max @ 100 = 100 * 0.03 = 3.0px/frame
                    const pixels = this.prompter.speed * 0.03;
                    preciseScrollTop += pixels;
                    container.scrollTop = preciseScrollTop;

                    // Loop
                    this.prompter.scrollIds = requestAnimationFrame(scrollStep);
                };
                this.prompter.scrollIds = requestAnimationFrame(scrollStep);
            },
            stopScrolling() {
                this.prompter.isScrolling = false;
                if (this.prompter.scrollIds) cancelAnimationFrame(this.prompter.scrollIds);
            },
            markAsRecorded() {
                if(!confirm("Finish recording and send to Editor?")) return;
                
                this.stopScrolling();
                this.saving = true;
                this.$set(this.editingVideo, 'status', 'edit_ready'); // Optimistic

                google.script.run
                    .withSuccessHandler(() => {
                        this.saving = false;
                        this.closeTeleprompter();
                        this.fetchVideos(true);
                    })
                    .withFailureHandler((err) => {
                        alert("Error: " + err);
                        this.saving = false;
                    })
                    .saveVideo(this.editingVideo);
            },
            finishAndNext() {
                // Find next 'recording_ready' video
                // We use 'videos' (all loaded) not filteredVideos to ensure we search everything relevant
                // Sort by sheet order? videos is already in sheet order (reversed? getVideos reverses it).
                // Actually getVideos reverses it to show newest keys first. 
                // So "Top of list" might mean "Next item in the array" if array is display order?
                // Or user means "Top of the pending list".
                // I will search for the first video in the current list that is 'recording_ready'.
                
                const nextVideo = this.videos.find(v => v.status === 'recording_ready');
                
                if (!nextVideo) {
                    alert("No more videos ready for recording!");
                    return;
                }

                if(!confirm(`Finish this video and start recording "${nextVideo.title_de || 'Next Video'}"?`)) return;

                this.stopScrolling();
                this.saving = true;

                // Call Backend Transaction
                google.script.run
                    .withSuccessHandler(() => {
                        this.saving = false;
                        // The auto-switch logic in onVideosLoaded will handle opening the new video
                        // because we just set it to 'recording'
                        this.fetchVideos(true); 
                    })
                    .withFailureHandler((err) => {
                        alert("Error switching video: " + err);
                        this.saving = false;
                    })
                    .finishAndNextRecording(this.editingVideo.id, nextVideo.id);
            },
            // UTILS
            getVideoTitle(video) {
                return this.dashboardLanguage === 'de' ? video.title_de : video.title_en;
            },
            getVideoTeaser(video) {
                const text = this.dashboardLanguage === 'de' ? video.text_de : video.text_en;
                if (!text) return 'No Text';
                return text.length > 60 ? text.substring(0, 60) + '...' : text;
            },
            renderMarkdown(text) {
                if (!text) return '';
                
                // FORCE PARAGRAPHS: Turn single Sheet newlines into Markdown double-newlines
                // This ensures every line in the Sheet becomes a distinct paragraph
                // which can then be spaced by the slider.
                const formatted = text.replace(/\n/g, '\n\n');
                
                // Configure marked to break on single newlines if desired, or standard markdown
                // marked.setOptions({ breaks: true }); 
                return marked.parse(formatted);
            }
        }
    });
</script>