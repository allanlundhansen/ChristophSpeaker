<script>
    new Vue({
        el: '#app',
        data: {
            currentRole: 'All',
            viewMode: 'dashboard',
            layoutMode: 'grid',
            editingVideo: {},
            tagInput: '',
            sourceInput: '',
            saving: false,
            translating: false,
            debounceTimer: null,
            loading: true,
            videos: [],
            error: null,
            filterStatus: 'All',
            prompter: {
                isScrolling: false,
                speed: 2,
                fontSize: 60,
                paragraphSpacing: 50, // Default pixels
                mirror: false,
                showGuides: true,
                scrollIds: null
            }
        },
        computed: {
            filteredVideos() {
                let filtered = this.videos;

                // 1. Filter by Role
                if (this.currentRole !== 'All') {
                    let roleStatuses = [];
                    if (this.currentRole === 'Author') roleStatuses = ['draft'];
                    else if (this.currentRole === 'Director') roleStatuses = ['recording_ready', 'recording'];
                    else if (this.currentRole === 'Speaker') roleStatuses = ['recording'];
                    else if (this.currentRole === 'Editor') roleStatuses = ['edit_ready'];
                    else if (this.currentRole === 'Manager') roleStatuses = ['publish_ready', 'published'];
                    
                    filtered = filtered.filter(v => roleStatuses.includes(v.status));
                }

                // 2. Filter by View/Status
                if (this.filterStatus !== 'All') {
                    filtered = filtered.filter(v => v.status === this.filterStatus);
                }

                const statusOrder = this.statuses;
                filtered.sort((a, b) => {
                    return statusOrder.indexOf(a.status) - statusOrder.indexOf(b.status);
                });

                return filtered;
            },
            statuses() {
                return ['draft', 'recording_ready', 'recording', 'edit_ready', 'publish_ready', 'published'];
            },
            customTags() {
                return this.editingVideo.tags || '';
            },
            // PARSES BOTH LEGACY STRINGS AND NEW JSON OBJECTS
            parsedSources() {
                // Ensure we handle the source_link whether it's a newline string OR a JSON string
                let raw = this.editingVideo.source_link || '';
                let links = [];

                // Detect if JSON
                if (raw.trim().startsWith('[')) {
                    try {
                        links = JSON.parse(raw);
                    } catch (e) {
                        links = []; // Fallback
                    }
                } else {
                    // Legacy: split by newline, convert to simple objects
                    links = raw.split('\n').filter(Boolean).map(url => ({ url, text: url })); // text fallback
                }

                return links.map(linkObj => {
                    const link = linkObj.url || linkObj;
                    let type = 'generic';
                    let thumb = linkObj.image || ''; // Use metadata image if available
                    let label = linkObj.title || linkObj.hostname || 'Link';
                    let color = 'gray';

                    // YouTube (Auto-detect overrides metadata if its a direct YT link, usually better thumb)
                    const ytMatch = link.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/);
                    
                    if (ytMatch) {
                        type = 'youtube';
                        label = 'YouTube User'; 
                        color = 'red';
                        thumb = 'https://img.youtube.com/vi/' + ytMatch[1] + '/mqdefault.jpg';
                    } else if (link.indexOf('tiktok.com') !== -1) {
                        type = 'tiktok';
                        label = 'TikTok';
                        color = 'gray';
                    } else if (link.indexOf('instagram.com') !== -1) {
                        type = 'instagram';
                        label = 'Instagram';
                        color = 'pink';
                    } else if (!thumb) {
                         // Logic for generic without metadata image?
                         // We rely on the object having it.
                    }

                    return { url: link, type, thumb, label, color, description: linkObj.description };
                });
            }
        },
        mounted() {
            this.fetchVideos();

            setInterval(() => {
                if (!this.saving && this.viewMode === 'dashboard') {
                    this.fetchVideos(true);
                }
            }, 1000);
        },
        methods: {
            fetchVideos(silent = false) {
                if (!silent) this.loading = true;
                google.script.run
                    .withSuccessHandler(this.onVideosLoaded)
                    .withFailureHandler(this.onFailure)
                    .getVideos();
            },
            onVideosLoaded(data) {
                // Ignore background polls if we are in the middle of a user action/save
                if (this.saving) return;
                this.videos = data;
                this.loading = false;
            },
            onFailure(error) {
                this.error = "Error loading videos: " + error.message;
                this.loading = false;
            },
            openNewVideoModal() {
                this.editingVideo = { status: 'draft' };
                this.viewMode = 'edit';
            },
            openEditModal(video) {
                this.editingVideo = JSON.parse(JSON.stringify(video));
                this.viewMode = 'edit';
            },
            openDetailView(video) {
                // SMART CLICK: If Speaker + Recording -> Open Teleprompter directly
                if (this.currentRole === 'Speaker' && video.status === 'recording') {
                    this.openTeleprompter(video);
                    return;
                }

                this.editingVideo = JSON.parse(JSON.stringify(video));
                this.tagInput = '';
                this.sourceInput = '';
                this.viewMode = 'detail';
            },
            closeDetailView() {
                this.viewMode = 'dashboard';
                this.editingVideo = {};
            },
            closeModal() {
                this.viewMode = 'dashboard';
                this.editingVideo = {};
            },
            saveVideo() {
                this.saving = true;
                const wasEditing = this.viewMode === 'edit';
                google.script.run
                    .withSuccessHandler(() => {
                        this.saving = false;
                        if (wasEditing) {
                            this.closeModal();
                        }
                        this.fetchVideos(true);
                    })
                    .withFailureHandler((err) => {
                        this.saving = false;
                        alert("Save Failed: " + err.message);
                    })
                    .saveVideo(this.editingVideo);
            },
            deleteVideo(video) {
                // If video is passed (Dashboard delete), use it. Otherwise use editingVideo (Detail delete).
                const targetId = video ? video.id : this.editingVideo.id;
                
                if(!confirm("Are you sure you want to delete this video? This cannot be undone.")) return;
                
                // If deleting the currently open video, we show saving state
                if (!video) this.saving = true;

                google.script.run
                    .withSuccessHandler(() => {
                        this.saving = false;
                        if (!video) this.closeDetailView(); // Close only if inside detail view
                        this.fetchVideos(true);
                    })
                    .withFailureHandler((err) => {
                        this.saving = false;
                        alert("Delete Failed: " + err);
                    })
                    .deleteVideo(targetId);
            },
            getStatusColor(status) {
                const colors = {
                    'draft': 'bg-gray-200 text-gray-800',
                    'recording_ready': 'bg-yellow-100 text-yellow-800',
                    'recording': 'bg-red-100 text-red-800',
                    'edit_ready': 'bg-purple-100 text-purple-800',
                    'publish_ready': 'bg-green-100 text-green-800',
                    'published': 'bg-green-500 text-white'
                };
                return colors[status] || 'bg-gray-100';
            },
            translateField(text, targetField) {
                if (!text) {
                    this.$set(this.editingVideo, targetField, "");
                    return;
                }
                this.translating = true;
                google.script.run
                    .withSuccessHandler((translatedText) => {
                        this.$set(this.editingVideo, targetField, translatedText);
                        this.translating = false;
                    })
                    .withFailureHandler(() => {
                        this.translating = false;
                    })
                    .translateText(text, 'de', 'en');
            },
            debouncedTranslate(field, val) {
                if (this.debounceTimer) clearTimeout(this.debounceTimer);
                this.debounceTimer = setTimeout(() => {
                    const target = field === 'title_de' ? 'title_en' : 'text_en';
                    this.translateField(val, target);
                }, 1000);
            },
            addTag() {
                if (!this.tagInput) return;
                const newTag = this.tagInput.trim().replace(/^#/, '');
                if (!newTag) return;
                
                let currentTags = this.customTags ? this.customTags.split(',').map(t => t.trim()).filter(Boolean) : [];
                if (!currentTags.includes(newTag)) {
                    currentTags.push(newTag);
                    this.$set(this.editingVideo, 'tags', currentTags.join(', '));
                }
                this.tagInput = '';
            },
            removeTag(index) {
                let currentTags = this.customTags ? this.customTags.split(',').map(t => t.trim()).filter(Boolean) : [];
                currentTags.splice(index, 1);
                this.$set(this.editingVideo, 'tags', currentTags.join(', '));
            },
            // UPGRADED ASYNC SOURCE ADD
            addSource() {
                if (!this.sourceInput) return;
                const newLink = this.sourceInput.trim();
                if (!newLink) return;

                // Disable input while fetching
                const originalInput = this.sourceInput;
                this.sourceInput = 'Fetching Preview...';

                google.script.run
                 .withSuccessHandler((meta) => {
                     let current = [];
                     const raw = this.editingVideo.source_link || '';
                     if (raw.startsWith('[')) {
                         try { current = JSON.parse(raw); } catch(e) {}
                     } else {
                         current = raw.split('\n').filter(Boolean).map(u => ({ url: u })); 
                     }

                     // Push new metadata object
                     if (meta.success) {
                        current.push(meta); 
                     } else {
                         // Fallback if fetch failed
                        current.push({ url: newLink, title: newLink });
                     }

                     // Save back as JSON string
                     this.$set(this.editingVideo, 'source_link', JSON.stringify(current));
                     this.sourceInput = ''; // Clear
                 })
                 .withFailureHandler((err) => {
                     alert("Could not fetch link: " + err);
                     this.sourceInput = originalInput;
                 })
                 .fetchLinkMetadata(newLink);
            },
            removeSource(index) {
                let current = [];
                const raw = this.editingVideo.source_link || '';
                if (raw.startsWith('[')) {
                    try { current = JSON.parse(raw); } catch(e) {}
                 } else {
                    current = raw.split('\n').filter(Boolean).map(u => ({ url: u })); 
                 }
                
                current.splice(index, 1);
                this.$set(this.editingVideo, 'source_link', JSON.stringify(current));
            },
            openLink(url) {
                window.open(url, '_blank');
            },
            // DIRECTOR: Set active recording
            setRecordingStatus(video) {
                // LOCK Polling to prevent race condition
                this.saving = true; 

                // 1. Optimistic UI Update
                const targetId = video.id;
                this.videos.forEach(v => {
                    if (v.id === targetId) {
                        v.status = 'recording';
                    } else if (v.status === 'recording') {
                        v.status = 'recording_ready';
                    }
                });

                // 2. Sync Detail View if open and matching
                if (this.editingVideo && this.editingVideo.id === targetId) {
                    this.editingVideo.status = 'recording';
                    // If other video was open? Unlikely edge case, not handled here.
                }

                // 3. Server Call
                google.script.run
                    .withSuccessHandler(() => {
                        console.log("Recording status synced.");
                        this.saving = false; // Release lock
                        this.fetchVideos(true); // Fetch immediately to confirm server state
                    })
                    .withFailureHandler((err) => {
                        alert("Failed to set recording status: " + err);
                        this.saving = false; // Release lock
                        this.fetchVideos(); // Revert on error
                    })
                    .setAsActiveRecording(targetId);
            },
            // TELEPROMPTER LOGIC
            openTeleprompter(video) {
                this.editingVideo = JSON.parse(JSON.stringify(video));
                // Default settings if not set?
                this.prompter.isScrolling = false;
                this.viewMode = 'teleprompter';
            },
            closeTeleprompter() {
                this.stopScrolling();
                this.viewMode = 'dashboard';
                this.editingVideo = {};
            },
            toggleScrolling() {
                if (this.prompter.isScrolling) {
                    this.stopScrolling();
                } else {
                    this.startScrolling();
                }
            },
            startScrolling() {
                if (this.prompter.isScrolling) return;
                this.prompter.isScrolling = true;
                
                const container = document.getElementById('prompter-content');
                if (!container) return; // Safety

                // SUB-PIXEL SCROLLING FIX:
                // Browsers often truncate scrollTop assignments. We must track the precise float value.
                let preciseScrollTop = container.scrollTop;

                const scrollStep = () => {
                    if (!this.prompter.isScrolling) return;
                    
                    // Logic: Speed 1 = 0.1px/frame, Speed 100 = 10px/frame
                    // Speed 4 = 0.4px/frame (accumulates to 2px every 5 frames)
                    const pixels = this.prompter.speed * 0.1;
                    preciseScrollTop += pixels;
                    container.scrollTop = preciseScrollTop;

                    // Loop
                    this.prompter.scrollIds = requestAnimationFrame(scrollStep);
                };
                this.prompter.scrollIds = requestAnimationFrame(scrollStep);
            },
            stopScrolling() {
                this.prompter.isScrolling = false;
                if (this.prompter.scrollIds) cancelAnimationFrame(this.prompter.scrollIds);
            },
            markAsRecorded() {
                if(!confirm("Finish recording and send to Editor?")) return;
                
                this.stopScrolling();
                this.saving = true;
                this.$set(this.editingVideo, 'status', 'edit_ready'); // Optimistic

                google.script.run
                    .withSuccessHandler(() => {
                        this.saving = false;
                        this.closeTeleprompter();
                        this.fetchVideos(true);
                    })
                    .withFailureHandler((err) => {
                        alert("Error: " + err);
                        this.saving = false;
                    })
                    .saveVideo(this.editingVideo);
            },
            // UTILS
            renderMarkdown(text) {
                if (!text) return '';
                
                // FORCE PARAGRAPHS: Turn single Sheet newlines into Markdown double-newlines
                // This ensures every line in the Sheet becomes a distinct paragraph
                // which can then be spaced by the slider.
                const formatted = text.replace(/\n/g, '\n\n');
                
                // Configure marked to break on single newlines if desired, or standard markdown
                // marked.setOptions({ breaks: true }); 
                return marked.parse(formatted);
            }
        }
    });
</script>